# 概要

BLEの通信をProtocol Buffersを用いて実現する。
仕様は下記のとおり。

- Protocol Buffersを利用して通信する型を定義し取り出せるようにする
- CentralがProtocol Buffersの関数を呼び出す形でPeripheralにデータをリクエストする
- BLEの上限に近い速度で通信できるようにする
- リトライ処理を実装し通信の過程で欠損が起きないようにする
- データの結合処理を実装し、MTUの上限を突破するデータも送れるようにする
- Central、Peripheralそれぞれの実装を用意する
- サポートする言語を複数用意する
- 組み込み用の実装はメモリ消費を極力避ける実装にする
- 将来的にiOS、Android、macOS、Windows、Linux等のプラットフォームで動作するようにする

# 実装するレイヤー

具体的な実装はコンテナ分割/結合レイヤーとコマンドエンコード/デコードレイヤーを用意する。
コマンドレイヤーでエンコードされたデータはコンテナレイヤーで分割されて送信される。
受信側ではコンテナレイヤーで結合されたデータをコマンドレイヤーでデコードする。

## コンテナ分割/結合レイヤー

コンテナの分割/結合を行い、MTUの上限を突破できるようにする。
リトライ処理を実装し、データが欠損した場合は再送を行う。
1トランザクションあたりのペイロード合計は最大65,535Byte（sequence_number 8bitの制約により実用上は約60KB）とする。
それ以上のデータはサポート外とし、request/responseを繰り返すことで対応する。

### コンテナフォーマット

コンテナは下記の形式で作成し、payloadにエンコードされたコマンドのデータを格納する（カッコ内はbit数）。

| transaction_id (8) | sequence_number (8) | type (2) | control_cmd (4) | reserved (2) | total_length (16 or 0) | payload_len (8) | payload (可変) |

- **transaction_id**: トランザクション（Protocol Buffersのコマンド単位）を一意に識別するためのID。コマンドのrequest/responseの一往復は同一トランザクションで行われる
- **sequence_number**: コンテナパケットを1つ送信するたびにインクリメントする値。トランザクションごとにリセットされる
- **type**: コンテナの種別
  - `0b00`: 先頭（first）
  - `0b01`: 後続（subsequent）
  - `0b11`: 制御（control）
- **control_cmd**: 制御コマンドの種別。type=0b11の場合のみ有効。それ以外のtypeでは0x0固定
  - `0x0`: 未使用
  - `0x1`: タイムアウト共有
  - `0x2`: ストリーム終了（Central → Peripheral）
  - `0x3`: ストリーム終了（Peripheral → Central）
  - `0x4`: ケイパビリティ共有
- **reserved**: 予約領域（0埋め）
- **total_length**: コンテナを全て結合したときのpayloadの合計長。type=0b00（先頭）の場合のみ付与し、type=0b01（後続）およびtype=0b11（制御）の場合は省略する。単位はByte
- **payload_len**: payloadの長さ。単位はByte
- **payload**: 分割されたデータ

### 制御コンテナ (type=0b11)

#### タイムアウト共有 (control_cmd=0x1)

Peripheral側の処理性能に応じたタイムアウト時間をCentralに共有する。CentralがPeripheralにタイムアウト値を要求し、Peripheralが応答する。

**タイムアウト要求（Central → Peripheral）:**

| transaction_id (8) | sequence_number (8) | type=0b11 (2) | control_cmd=0x1 (4) | reserved (2) | payload_len=0x00 (8) |

**タイムアウト応答（Peripheral → Central）:**

| transaction_id (8) | sequence_number (8) | type=0b11 (2) | control_cmd=0x1 (4) | reserved (2) | payload_len=0x02 (8) | timeout_ms (16) |

- timeout_ms: タイムアウト値（単位: ms、リトルエンディアン）

#### ストリーム終了 Central → Peripheral (control_cmd=0x2)

CentralからPeripheralに対してストリームの終了を通知する。

| transaction_id (8) | sequence_number (8) | type=0b11 (2) | control_cmd=0x2 (4) | reserved (2) | payload_len=0x00 (8) |

#### ストリーム終了 Peripheral → Central (control_cmd=0x3)

PeripheralからCentralに対してストリームの終了を通知する。

| transaction_id (8) | sequence_number (8) | type=0b11 (2) | control_cmd=0x3 (4) | reserved (2) | payload_len=0x00 (8) |

#### ケイパビリティ共有 (control_cmd=0x4)

Peripheral側のバッファ制限をCentralに共有する。CentralがPeripheralにケイパビリティを要求し、Peripheralが応答する。

**ケイパビリティ要求（Central → Peripheral）:**

| transaction_id (8) | sequence_number (8) | type=0b11 (2) | control_cmd=0x4 (4) | reserved (2) | payload_len=0x00 (8) |

**ケイパビリティ応答（Peripheral → Central）:**

| transaction_id (8) | sequence_number (8) | type=0b11 (2) | control_cmd=0x4 (4) | reserved (2) | payload_len=0x04 (8) | max_request_payload_size (16) | max_response_payload_size (16) |

- max_request_payload_size: Peripheralが受信可能なリクエストペイロードの最大サイズ（単位: Byte、リトルエンディアン）。アセンブラバッファサイズに相当
- max_response_payload_size: Peripheralが送信可能なレスポンスペイロードの最大サイズ（単位: Byte、リトルエンディアン）

## コマンドエンコード/デコードレイヤー

Protocol Buffersでエンコードしたデータにコマンド情報を付与して通信する。
Central側からの1回のrequest（write without response）に対して、必ずPeripheralから1回のresponse（notify）が返る。

### コマンドフォーマット

コマンドは下記の形式で作成し、dataにProtocol Buffersでエンコードされたデータを格納する（カッコ内はbit数）。

| type (1) | reserved (7) | cmd_name_len (8) | cmd_name (cmd_name_len * 8) | data_len (16) | data (data_len * 8) |

- **type**: `0` = request、`1` = response
- **cmd_name_len**: cmd_nameの長さ。単位はByte
- **cmd_name**: ASCIIコードで表記されるコマンド名
- **data_len**: dataの長さ。単位はByte
- **data**: Protocol Buffersでエンコードされたバイト列

# BLEの実装

## Characteristic

通信はすべて1つのCharacteristicを用いて行う。Protocol Buffersの関数呼び出し時の書き込みはCharacteristicのwrite without responseを用いて行い、それに対する応答をnotifyで返す。

## タイムアウト

write without responseのあと、タイムアウト時間内にnotifyが返ってこない場合はタイムアウトとして関数呼び出しを終了する。デフォルトのタイムアウトは**100ms**とする。Peripheral側からタイムアウト共有コンテナ（control_cmd=0x1）を用いてデフォルトのタイムアウト時間を上書きできる。

## Stream

Protocol Buffersのstreamを実装するときは、notifyでデータを連続送信する。コンテナ単位で欠損を検知した場合（sequence_numberのギャップ）、そのメッセージ全体を破棄する。ストリームの終了は制御コンテナ（control_cmd=0x2またはcontrol_cmd=0x3）で通知する。Central、Peripheralどちらからでもストリームを終了できる。

## MTU

MTUの交換はBLEのATT MTU Exchange手順により自動的に行われるため、独自の制御コマンドは不要とする。アプリケーション層ではBLEスタックから取得したネゴシエーション済みMTUを参照し、コンテナのペイロードサイズを決定する。

# 初期方針

まずはテストとしてCentralをMac上でPythonを使って実装し、PeripheralをNordicのnRF54L15 DKで実装する。
初期は下記のコマンドを実装する。

- 同じ文字列を返すechoコマンド
- nRF54L15 DKのFlashからデータを取り出すコマンド（速度テスト用）
