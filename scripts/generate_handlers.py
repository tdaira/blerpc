#!/usr/bin/env python3
"""Generate handler stubs and client code from blerpc.proto.

Parses proto file with regex (no protobuf compiler dependency) and generates:
- peripheral/src/generated_handlers.h  — C declarations + handler_entry + lookup
- peripheral/src/generated_handlers.c  — weak handler stubs + handler table
- peripheral_py/generated_handlers.py  — Python handler stubs + HANDLERS dict
- central/blerpc/generated/generated_client.py — Python client mixin class
"""

import os
import re
import sys

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)

PROTO_FILE = os.path.join(PROJECT_ROOT, "proto", "blerpc.proto")
OPTIONS_FILE = os.path.join(PROJECT_ROOT, "proto", "blerpc.options")

OUT_C_HEADER = os.path.join(PROJECT_ROOT, "peripheral", "src", "generated_handlers.h")
OUT_C_SOURCE = os.path.join(PROJECT_ROOT, "peripheral", "src", "generated_handlers.c")
OUT_PY_HANDLERS = os.path.join(PROJECT_ROOT, "peripheral_py", "generated_handlers.py")
OUT_PY_CLIENT = os.path.join(
    PROJECT_ROOT, "central", "blerpc", "generated", "generated_client.py"
)

# Proto field type → Python default value (for keyword args)
PYTHON_DEFAULTS = {
    "string": "''",
    "bytes": "b''",
    "uint32": "0",
    "int32": "0",
    "uint64": "0",
    "int64": "0",
    "float": "0.0",
    "double": "0.0",
    "bool": "False",
}


def camel_to_snake(name: str) -> str:
    """Convert CamelCase to snake_case."""
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    return s.lower()


def parse_proto(proto_path: str) -> list[dict]:
    """Parse proto file for message definitions and their fields.

    Returns list of dicts: {name, fields: [{name, type, number}]}
    """
    with open(proto_path) as f:
        content = f.read()

    messages = []
    for m in re.finditer(r"message\s+(\w+)\s*\{([^}]*)\}", content):
        msg_name = m.group(1)
        fields = []
        for field in re.finditer(r"(\w+)\s+(\w+)\s*=\s*(\d+)", m.group(2)):
            fields.append(
                {
                    "type": field.group(1),
                    "name": field.group(2),
                    "number": int(field.group(3)),
                }
            )
        messages.append({"name": msg_name, "fields": fields})
    return messages


def parse_options(options_path: str) -> set[str]:
    """Parse .options file for FT_CALLBACK annotations.

    Returns set of "MessageName.field_name" strings that use FT_CALLBACK.
    """
    callbacks = set()
    if not os.path.exists(options_path):
        return callbacks
    with open(options_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            # Format: blerpc.MessageName.field_name  type:FT_CALLBACK
            if "FT_CALLBACK" in line:
                parts = line.split()
                if parts:
                    # Strip package prefix "blerpc."
                    qualified = parts[0]
                    if qualified.startswith("blerpc."):
                        qualified = qualified[len("blerpc.") :]
                    callbacks.add(qualified)
    return callbacks


def discover_commands(messages: list[dict]) -> list[dict]:
    """Discover Request/Response pairs and derive command info.

    Returns list of dicts: {
        camel: "FlashRead",
        snake: "flash_read",
        request_msg: "FlashReadRequest",
        response_msg: "FlashReadResponse",
        request_fields: [...],
        response_fields: [...],
    }
    """
    msg_by_name = {m["name"]: m for m in messages}
    commands = []
    for msg in messages:
        if msg["name"].endswith("Request"):
            camel = msg["name"][: -len("Request")]
            resp_name = camel + "Response"
            if resp_name in msg_by_name:
                commands.append(
                    {
                        "camel": camel,
                        "snake": camel_to_snake(camel),
                        "request_msg": msg["name"],
                        "response_msg": resp_name,
                        "request_fields": msg["fields"],
                        "response_fields": msg_by_name[resp_name]["fields"],
                    }
                )
    return commands


def generate_c_header(commands: list[dict]) -> str:
    """Generate generated_handlers.h content."""
    lines = [
        "/* Auto-generated by generate_handlers.py — DO NOT EDIT */",
        "#ifndef BLERPC_GENERATED_HANDLERS_H",
        "#define BLERPC_GENERATED_HANDLERS_H",
        "",
        "#include <stdint.h>",
        "#include <stddef.h>",
        "#include <pb_encode.h>",
        "",
        "#ifdef __cplusplus",
        'extern "C" {',
        "#endif",
        "",
        "typedef int (*command_handler_fn)(const uint8_t *req_data, size_t req_len,",
        "                                  pb_ostream_t *ostream);",
        "",
        "struct handler_entry {",
        "    const char *name;",
        "    uint8_t name_len;",
        "    command_handler_fn handler;",
        "};",
        "",
        "command_handler_fn handlers_lookup(const char *name, uint8_t name_len);",
        "",
    ]
    for cmd in commands:
        lines.append(
            f"int handle_{cmd['snake']}(const uint8_t *req_data, size_t req_len,"
        )
        lines.append(
            f"                {' ' * len(cmd['snake'])}pb_ostream_t *ostream);"
        )
        lines.append("")

    lines += [
        "#ifdef __cplusplus",
        "}",
        "#endif",
        "",
        "#endif /* BLERPC_GENERATED_HANDLERS_H */",
        "",
    ]
    return "\n".join(lines)


def generate_c_source(commands: list[dict], callbacks: set[str]) -> str:
    """Generate generated_handlers.c content."""
    lines = [
        "/* Auto-generated by generate_handlers.py — DO NOT EDIT */",
        '#include "generated_handlers.h"',
        '#include "blerpc.pb.h"',
        "#include <pb_encode.h>",
        "#include <pb_decode.h>",
        "#include <string.h>",
        "",
        "/* Discard callback for FT_CALLBACK fields during decode */",
        "static bool discard_bytes_cb(pb_istream_t *stream, const pb_field_t *field,",
        "                             void **arg)",
        "{",
        "    (void)field;",
        "    (void)arg;",
        "    uint8_t buf[64];",
        "    size_t left = stream->bytes_left;",
        "    while (left > 0) {",
        "        size_t n = left < sizeof(buf) ? left : sizeof(buf);",
        "        if (!pb_read(stream, buf, n)) return false;",
        "        left -= n;",
        "    }",
        "    return true;",
        "}",
        "",
    ]

    # Generate weak handler stubs
    for cmd in commands:
        req_msg = f"blerpc_{cmd['request_msg']}"
        resp_msg = f"blerpc_{cmd['response_msg']}"

        lines.append("__attribute__((weak))")
        lines.append(
            f"int handle_{cmd['snake']}(const uint8_t *req_data, size_t req_len,"
        )
        lines.append(f"                {' ' * len(cmd['snake'])}pb_ostream_t *ostream)")
        lines.append("{")

        # Decode request (with discard callback for FT_CALLBACK fields)
        lines.append(f"    {req_msg} req = {req_msg}_init_zero;")

        # Set discard callbacks for FT_CALLBACK request fields
        for field in cmd["request_fields"]:
            key = f"{cmd['request_msg']}.{field['name']}"
            if key in callbacks:
                lines.append(
                    f"    req.{field['name']}.funcs.decode = discard_bytes_cb;"
                )

        lines.append(
            "    pb_istream_t stream = pb_istream_from_buffer(req_data, req_len);"
        )
        lines.append(f"    if (!pb_decode(&stream, {req_msg}_fields, &req)) return -1;")
        lines.append("")

        # Encode zero-initialized response
        lines.append(f"    {resp_msg} resp = {resp_msg}_init_zero;")
        lines.append(
            f"    if (!pb_encode(ostream, {resp_msg}_fields, &resp)) return -1;"
        )
        lines.append("    return 0;")
        lines.append("}")
        lines.append("")

    # Handler table
    lines.append("static const struct handler_entry handler_table[] = {")
    for cmd in commands:
        name = cmd["snake"]
        lines.append(f'    {{"{name}", {len(name)}, handle_{name}}},')
    lines.append("};")
    lines.append("")

    # Lookup function
    lines.append(
        "command_handler_fn handlers_lookup(const char *name, uint8_t name_len)"
    )
    lines.append("{")
    lines.append("    size_t i;")
    lines.append(
        "    for (i = 0; i < sizeof(handler_table) / sizeof(handler_table[0]); i++) {"
    )
    lines.append("        if (handler_table[i].name_len == name_len &&")
    lines.append("            memcmp(handler_table[i].name, name, name_len) == 0) {")
    lines.append("            return handler_table[i].handler;")
    lines.append("        }")
    lines.append("    }")
    lines.append("    return NULL;")
    lines.append("}")
    lines.append("")

    return "\n".join(lines)


def generate_py_handlers(commands: list[dict]) -> str:
    """Generate peripheral_py/generated_handlers.py content."""
    lines = [
        '"""Auto-generated by generate_handlers.py — DO NOT EDIT."""',
        "",
        "import os",
        "import sys",
        "",
        "sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'central'))",
        "from blerpc.generated import blerpc_pb2",
        "",
        "",
    ]

    for cmd in commands:
        req_cls = f"blerpc_pb2.{cmd['request_msg']}"
        resp_cls = f"blerpc_pb2.{cmd['response_msg']}"
        lines.append(f"def handle_{cmd['snake']}(req_data):")
        lines.append(f"    req = {req_cls}()")
        lines.append("    req.ParseFromString(req_data)")
        lines.append(f"    return {resp_cls}().SerializeToString()")
        lines.append("")
        lines.append("")

    # HANDLERS dict
    lines.append("HANDLERS = {")
    for cmd in commands:
        lines.append(f'    "{cmd["snake"]}": handle_{cmd["snake"]},')
    lines.append("}")
    lines.append("")

    return "\n".join(lines)


def generate_py_client(commands: list[dict]) -> str:
    """Generate central/blerpc/generated/generated_client.py content."""
    lines = [
        '"""Auto-generated by generate_handlers.py — DO NOT EDIT."""',
        "",
        "from __future__ import annotations",
        "",
        "from . import blerpc_pb2",
        "",
        "",
        "class GeneratedClientMixin:",
        '    """Auto-generated RPC methods.',
        "",
        "    Override in subclass for custom return types.",
        '    """',
        "",
    ]

    for cmd in commands:
        req_cls = f"blerpc_pb2.{cmd['request_msg']}"
        resp_cls = f"blerpc_pb2.{cmd['response_msg']}"

        # Build keyword args from request fields
        params = []
        for field in cmd["request_fields"]:
            default = PYTHON_DEFAULTS.get(field["type"], "None")
            params.append(f"{field['name']}={default}")

        params_str = ", ".join(params)
        if params_str:
            params_str = ", *, " + params_str
        else:
            params_str = ""

        # Build request constructor kwargs
        kwargs = ", ".join(f"{f['name']}={f['name']}" for f in cmd["request_fields"])

        lines.append(f"    async def {cmd['snake']}(self{params_str}):")
        lines.append(f'        """Call the {cmd["snake"]} command."""')
        lines.append(f"        req = {req_cls}({kwargs})")
        call_line = f'await self._call("{cmd["snake"]}", req.SerializeToString())'
        lines.append(f"        resp_data = {call_line}")
        lines.append(f"        resp = {resp_cls}()")
        lines.append("        resp.ParseFromString(resp_data)")
        lines.append("        return resp")
        lines.append("")

    return "\n".join(lines)


def main():
    messages = parse_proto(PROTO_FILE)
    callbacks = parse_options(OPTIONS_FILE)
    commands = discover_commands(messages)

    if not commands:
        print("No Request/Response pairs found in proto file.", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(commands)} commands: {', '.join(c['snake'] for c in commands)}")

    # Generate all files
    for path, content in [
        (OUT_C_HEADER, generate_c_header(commands)),
        (OUT_C_SOURCE, generate_c_source(commands, callbacks)),
        (OUT_PY_HANDLERS, generate_py_handlers(commands)),
        (OUT_PY_CLIENT, generate_py_client(commands)),
    ]:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w") as f:
            f.write(content)
        print(f"  Generated {os.path.relpath(path, PROJECT_ROOT)}")


if __name__ == "__main__":
    main()
